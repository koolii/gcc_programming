# ふつうのLinuxプログラミング［第二版］Linuxの仕組みから学べるgccプログラミングの王道

## 2章OS

LinuxとはOSやディストリビューションのことのように見えるが実際はカーネルのこと

### Linuxのセカイを構成する３つの要素
* ファイルシステム
* プロセス
* ストリーム

### ハードウェア操作でのカーネルの役割
カーネルは役割としてハードウェアの統括で、CPUやメモリ、HDDやCDドライブ等のデバイスを操作します
上記のように一言でいうと単純だがHDDを一つとっても沢山の種類が夫々に適したデバイスドライバ（単にドライバとも言う）を持っている

### システムコール
普通のプログラムがハードウェアを操作したいときはカーネルに仕事を頼んで間接的に操作するしかありません
カーネルは一番偉いプログラムだが、その一方で一番下っ端の仕事をしている
カーネルに仕事を頼むにはシステムコールの仕組みを使う

システムコールの「システム」は要するにカーネルのことで、「システムを呼び出す（call）」から名前が付いている
Linuxには下記のようなシステムコールが存在している

* open
* read
* write
* fork
* exec
* stat
* unlink

だが、システムコールも別に普通のプログラムで使われていて

```c
n = read(fd, buf, sizeof buf);
```

## ライブラリ

## libc
Linuxに用意されているライブラリは色々ありますが、
その中でも特に重要なライブラリが標準Cライブラリ（libc）
Linuxで普通使われているlibcはGNU libc（glibc）といって、その名の通りGNUプロダクトの一部
GNU libc自体はLinusさんが作ってるわけではないのでよく「Linuxはカーネルだけ」＝Linuxが作ってるのはLinusさんだけ

### API
APIは何かを使ってプログラミングするときのインターフェイスのことを指し、例えば
CのライブラリのAPIは関数やマクロです・カーネルのAPIはシステムコールとなる
かなりの数の人が「API」と「システムコール」を同じ意味だと思っているらしい

## 3章Linuxを生み出す3つの概念

### ファイルシステム
まずはファイルを理解する必要がある

* 広義のファイル
* 狭義のファイル
* ストリーム

### 広義のファイル
簡単に言えば`ls`コマンドで表示される一覧をファイルと呼べる

* 普通のファイル = **狭義のファイル**
  * 内容がそのまま記録されているファイル(テキスト、動画、写真、音声)
* ディレクトリ
  * 他のファイルを複数入れることができるファイル
* シンボリックリンク(ソフトリンク)
  * 主な使いみちは、ファイルやディレクトリに別名をつけること
* デバイスファイル
  * デバイス(ハードウェア)をファイルとして表現したもの
  * /dev/sdaは一台目のSSDまたはHDDを表している
  * /dev/nullは対応デバイスがないファイルで、読み込むと常に空、何かを書き込むとどこかに消えてしまうという不思議ファイル
* 名前付きパイプ
  * プロセス間通信に使うファイルでFIFOとも呼ばれる
* UNIXドメインソケット
  * プロセス間通信で使うファイルで、現在はTCPソケットで代替できる

#### まとめ
* どんなファイルであれ **何れかのデータを保持する**
* ファイルにはパーミッションや更新時刻等の **付帯情報がある**
* **名前（パス）で指定できる** ことはファイルに欠かせない特性

### プロセス
* 簡単に言えば「動作中のプログラム(=ファイルのような形態で存在しているデータも含む)」
* １つのプログラムから複数のプロセスを作成することができる

#### シグナル
* プロセスIDが代表的な例として、シグナルがある
* シグナルは`Ctrl+C`を押下した時の仕組みを支えていて、
* 流れはカーネルが該当プロセスに割り込みシグナル(*SIGINT*)を送り、それを受け取ったプロセスが自発的に終了します

### ストリーム(本書ではバイトストリームと同値)
* ストリームは、バイト列が流れる通り道だと考える
* プロセスがファイルやハードウェア(キーボード等)の内容にアクセスする時の橋渡し
  * ストリームからバイト列を読む = **read**
  * ストリームからバイト列を書く = **write**
* パイプの仕組みもストリームになっている
  * まず各コマンドを独立したプロセスとして同時に実行する
  * そのプロセス間をストリーム(パイプでつなぐ)
* ネットワーク間の通信でもストリーム(どっちかって言うとプロセス)
* パイプのように、プロセス同士がストリームを通じてデータをやりとりしたり意思の疎通を図ることを **プロセス間通信(IPC)** と言う
  * ストリームだけがプロセス間の橋渡しではない

##### 他書では
* 単に「ファイル」や「open file」と呼ばれている
* 「FILE型の値」や「STREAMSカーネルモジュール」の意味で使われている

### まとめ
* ファイルシステム
  * データに名前をつけて保存する場所
* プロセス
  * 何らかの活動をする主体
* ストリーム
  * プロセスがファイルシステムや他のプロセスとデータをやり取りする手段

## 4章Linuxとユーザ

### グループ
* ユーザをグループに所属させることができ、複数のグループに所属させることもでき、これらのグループは補足グループと呼ばれる
### パーミッション
* r=4
* w=2
* x=1
* -=0
* ディレクトリは不鬱のファイルとは少し違っていて、
  * 読み書きについては、ディレクトリを「その中にあるファイルのリストを記録したファイル」と考える
  * 実行に関しては、内部のファイルのパーミッションに関係なく、一切アクセスできなくなります

### クレデンシャル
例えばユーザAが所有しているファイル(rw-r--r--)があったとして、ユーザAとしてアクセスすればこのファイルを読み書きができます
「ユーザAとしてアクセス」するとは「ユーザAの属性を持ったプロセスがアクセスする」ということになる
Linux上で活動する主体はユーザではなくプロセスとなるのでユーザAの属性を持った別のユーザがアクセスすることができる
ここでのプロセスの属性としてのユーザのことをクレデンシャルといい、要するにユーザの代わりに代理として(プロセスが)動作していることを表す証明書
ログインの過程で、証明書をもつプロセスがシステム上に作成され、他のプロセスを実行するときに証明書をコピーされる

### /etc/passwd

```
daemon:x:1:10:daemon:/usr/sbin:/usr/sbin/nologin

```
* ユーザdaemonのユーザIDが1、グループIDが10となる
* グループの情報は/etc/groupに記載されている

### シェルと端末

* Unixではtty(=端末)となるがこれはテレタイプから来ている
* ビットマップディスプレイは細かい色の点の集まりで文字などを表現している

現代的なGUIを備えたPCで「a」を表示するときは、予めメモリ上に「a」を表現する画像を作っておき、「この画像を表示せよ」と命令します
具体的に、端末に「aという文字を表示しろ」と指定するには、文字と数値を対応付けてその数値を伝えていて、最も普及した規則がACSCII
端末もファイルとして表現されていて/dev以下に端末に対応するデバイスファイルが用意されている

このデバイスファイルが接続するためのストリームが得られるので、端末に繋がったストリームを読むとキーボードからの入力が得られ、
端末に繋がったストリームに書くとディスプレイに文字を出力できます

**そのためUNIXでは色々なものをファイルとして表現しようとする特徴があります**

## 5章ストリームにかかわるシステムコール

### 概略(ではあるがLinuxの入出力はこれでほぼ語り尽くせてしまう)
* ストリームからバイト列を読み込むread
* ストリームにバイト列を書き込むwrite
* ストリームを作るopen
* 用済みのストリームを始末するclose

### ファイルディスクリプタ
すでに説明済みだが、プロセスがファイルを読み書きしたり他のプロセスとやり取りをするときにはストリームを使いますが、
その使い方について触れる

プログラムからストリームを扱うにはファイルディスクリプタというものを使います
ファイルディスクリプタとはプログラムから見るとただの整数値(int)
理由はプロセスからカーネル内の実際のストリーム(を管理するデータ構造)を直接触れることができないため、
紐付けられている数値でストリームの操作をカーネルに依頼する

### 標準入出力・エラー出力
一番手間がないストリームが下記(ストリーム番号)
* 標準入出(0番)
* 標準出力(1番)
* 標準エラー出力(2番)

コマンドをパイプで繋いでデータを処理することができるのは
コマンドが標準入力からデータを読み込み、処理結果を標準出力に書き込むようになっているから

具体的な例として`$ grep print < hello.c | head`で考える
hello.cファイルを標準入力としてgrepプロセスに渡し、その標準入力をそのまま標準入力にしてheadプロセスに渡し、最終的に端末に結果を出力

### ストリームの読み書き

#### read(2)
この「(2)」はシステムコールを表す表現

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t bufsize);
```

`ssize_t`や`size_t`はどちらもsys/types.hで定義されている、基本的な整数型のエイリアスにすぎない
別名にする理由はカーネルやOS、CPUにかかわらず同じソースを使えるようにするため

`read`はfd番のストリームからバイト列を読み込むシステムコール
最大bufsizeバイト読み、bufに格納する(慣習としてbufのサイズをそのままbufsizeに指定する)

* 正常完了したら読み込んだバイト数を返す
* ファイル終端に達したときは0を返す
* エラーが起きたときは-1を返す

* read()はbufsizeバイトより少ないバイト数しか読まないケースも頻繁に起きるので返り値チェックが必須
* c言語の文字列は任意のバイト列が格納できるが、人間が読める文字列の場合は'\0'が終端になるのが慣習
* ただAPI毎に'\0'を終端と前提するものとしないものがあり
  * read()は'\0'が終端の前提になっていない
  * print()は'\0'が終端の前提になっている
  * read()で読み込んだ文字列をそのままprint()に渡すと単に結果が変になるだけでなく、セキュリティホールになりえる為間違い

#### write(2)
```c
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t bufsize);
```

* 正常に書き込んだときは書いたバイト数を返す
* エラーが起きたときは-1を返す

エラーが起きる可能性は低いが、厳密な処理では戻り値をチェックすべき

### ストリームの定義
本書のストリームは、ファイルディスクリプタで表現され、read()またはwrite()で操作できるもののこと
例えば、ファイルをopen()するとread()またはwrite()を実行できるものが作られるから、そこにストリームがある

### ファイルを開く
明示的に新しいストリームを作る方法について

#### open(2)
ファイルに接続するストリームを作成する

````c
# include <sys/types.h>
# include <sys/stat.h>
# include <fcntl.h>

int open(const char *path, int flags);
int open(const char *path, int flags, mode_t mode);
````

第一引数pathのパスで示されるファイルにつながるストリームを作成し、そのストリームを指すファイルディスクリプタを返します
この処理をファイルを開くと言う

#### close(2)
ストリームを始末するシステムコール

````c
# include <unistd.h>

int close(int fd);
````

ファイルディスクリプタfdに関連付けられているストリームを始末する
返り値が0なら問題なし、-1ならエラーとなる

本当のところ、close()をしなくても良いが、同時に接続できるプロセス数にも限度があるし
プロセスが終了できないときもあるので基本的にclose()することが大事

### その他のシステムコール

同じファイルディスクリプタに対して何度もread()システムコールを呼ぶと、必ず前回の続きが帰って来るということは
ファイルをどこまで読んだのかが記憶されているということになる、その位置のことをファイルオフセットという

````c
# include <types.h>
# include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
````

この値はシステムコールで操作でき、代表的なシステムコールはlseek()で指定した位置offsetに移動する
移動方法が３通りあり、それをwhence変数に指定する（P97参照）

## 6章ストリームにかかわるライブラリ関数
システムコールを直接使ってプログラムを作ると、バイト単位で設定したりシステムコールの処理速度の関係で
標準入出力ライブラリstdio(libcの大部分)のバッファリングを使いカーネルの上に一つ層をまたいだAPIを使う

FILE型はファイルディスクリプタを内部でラッパーした型でバッファ＋ストリームと考えると覚えやすいかも
* fileno(3) 引数のstreamがラップしているファイルディスクリプタを返す
* fdopen(3) ファイルディスクリプタをラップするFILE型の値を新しく生成してポインタを返す

* foepn(3) 標準入出力以外をストリームに対応させる(システムコールのopen)
* fclose(3) システムコールのclose
* fgetc(3) ストリームから1バイト読み込んで返す
* fputc(3) ストリームにバイトを書き込む
* getc(3) fgetcと全く同じだが、こっちはマクロとして定義されている
* putc(3) fputcと。。。
* getchar(3) getc(stdin)と同じ
* putchar(3) putc(c, stdout)と同じ* getc(3) fgetcと全く同じだが、こっちはマクロとして定義されている
* putc(3) fputcと。。。
* getchar(3) getc(stdin)と同じ
* putchar(3) putc(stdin)と同じ
* ungetc(3) １バイトをバッファに「戻す」APIで、１つのストリームに連続使用が出来ない、入力を単語に区切っていく時によく使う
  * e.g. +と=が区切り文字と識別したりするのに使用したりする => 1928+26=1954
* fgets(3) ストリームから１行読み込んで、第一引数に格納し、最大サイズsize-1までしかデータを読み込まない(末尾に\0を書き込むから)
  * getsはバッファサイズを指定できず、もしも第一引数に用意したバッファよりも一行が大きいと即死
* fputs(3) fputsとは違い一行単位ずつ書き込むわけではない、エラーの際はglobal変数のerrnoに値が挿入される
  * putsは必ず一行挿入する(=末尾に\nが挿入)のでファイルの一番最後のバッファにも\nがつくので注意、これは標準出力専用
* fread,fwrite システムコールのread(),write()とほぼ同じ
* fflush(3) 引数streamがバッファリングしている内容を即時write()させる、文字列を開業せずに端末に出力したいときに使う
* setvbuf(3) stdioに強制的に使わせることができ、バッファリングモードを変更することも可能
* clearerr(3) 第一引数streamのエラーフラグとEOFフラグをクリアする(結構使うらしい)


#### ファイルディスクリプタとFILE型の混在
* 基本的にFILE型にはバッファがあるため、FILE型でできることは全てFILE型でやることが望ましい
* でないと、バッファの関係で入出力がバラバラになってしまうことがあり得る
* 例外的にFILE型で操作できないファイルのパーミッション等を扱う際にのみファイルディスクリプタを使用する

#### なぜfread,fwriteが存在するのか？
* read(), write()はUnixのシステムコールだが、fread(),fwrite()はC言語の標準APIなので他の環境でも動作することが期待できる
* stdioには独自バッファがあり、fread(),fwrite()はその独自バッファの順番通りに書き込み読み込みを行うが、read(),write()は即時書き込みを行う

#### なぜclearerrはよく使うのか？
良い例がtailコマンドで一度書き込みが終わった(=EOFとなった)ファイルを
別のプロセスが内容を追加したらそれをread()で読むことができるように値(EOFフラグ)をクリアしてくれる
※ stdioはread()が一度でもEOFを返すとFILEにEOFフラグをセットして、それ以上read()を呼ばなくなる

```c
// これはどこがダメでなぜコメント以下のコードが良いのか？（P119)
char buf[1024];

fgets(buf, sizeof buf, stdin);
printf(buf);  // printf("%s", buf);
```

```c
// これはどこがダメ？（P127)
// feof()はEOFフラグを取得する関数でstreamの読み込み操作がEOFに到達した時にTRUEとなる
char buf[1024];

while (!feof(stdin)) {
  fgets(buf, 1023, stdin);
  fputs(buf, stdout);
}
```

## 7章headコマンドを作る

* オプションについて
  * 「-」と「--」が、ありロングオプションのパラメータは「--lines 5」や「--lines=5」と書いても構わない
  * APIとして`getopt(3)`がある、これはショートオプションしか認識しない
  * `getOpt_long(3)`はロングオプションを認識し、特別なのはoption構造体の配列を第4引数に受け付けること
    * headの「-n」と「--lines」が同一であるというような対応付け等も行うことができる(P147)
* オプション以外について
  * 「-」は「標準入力から入力せよ」と言う意味で使うことがある
  * 「--」は「ここでオプション解析を停止せよ」と言う意味で使うことがある(マイナスから始まる文字列を渡す時等)


### getOpt(3)について
* getOptを呼び出す毎に1つのオプションの結果を返すので無限ループとなり、終了条件は返り値が-1の時
  * 不正なオプションを受け取った場合は`?`を返却する
  * 第三引数は、そのコマンドで解析したいオプションを文字列(char*)で指定
    * "axf" これらはパラメータを取らないオプション(順序は関係ない)
    * "az:q" zオプションのみパラメータを取り、この場合はzの後に`:`を付与する
    * zオプションがgetOpsで返ってきた場合はグローバル変数「char *optarg」に格納されている(他にもある)
  * 実際の「-」と「--」の扱いについてはP145


## 8章grepコマンドを作る

### 文字コードについて
* UTF-8がデファクトだが、対応していない言語も多数あり、全ての文字コードを解決できているわけではない
* 他にはASCII、Shift_JISやEUC_JP等があるが、それぞれの言語に偏りがあり、それを統合解決するためにUTF-8は作られた
* ASCIIで表現できるのはchar型1バイト=8ビット分の256種類しか対応していないから日本語には全く使えない
* 文字コード(符号化文字集合、エンコード)
  * ワイドキャラクタ: 全ての文字に対して同じバイト数を使う手法(UTF-16)
  * マルチバイトキャラクタ: 文字の種類によってバイト数を変える手法(UTF-8,Shift JIS)
  * フローは符号化文字集合と言うなの文字と数値の対応表を使ってエンコード(文字を数値に変換)する
* プログラムが処理できる文字コードや文字を増やすことを「多言語化」
* 地域によって表示させる文字等を変更することを「地域化(localization)」

## 9章Linuxのディレクトリ構造
* /bin システムはブートする際に使用するコマンド置き場
* /usr/bin 一般ユーザ向けのコマンドで、自分でコマンドをインストールするなら/usr/local/binが良い
* /sbin ブート時にも必要な管理者用コマンドを配置し、/usr/sbinには平常時の管理コマンドやサーバプログラムを配置
  * 基本的に/usr以下に配置するものはシステム内のユーザが共有するもののみに留め、逆に個人利用だと/varに配置
* /usr/src LinuxKernel等のプログラムが配置
* /usr/include ヘッダファイル
* /usr/share 複数ユーザで共有できるファイルを配置、ドキュメントのみが良い
* /usr/share/man manのドキュメントが配置
* /usr/local /usrの階層とほぼ同じ構成だが、/usr側はディストリ管理、/usr/localはログインユーザ管理と権限が別れている
  * 自分で使用するプログラムなどはここからディレクトリを掘って、配置するなどが良い
  * /usr/localと同様の使われ方をしているのが/opt
  * pathの設定には気をつけて
* /var/run PIDファイル置き場だが最近は/runのシンボリックリンクが多い(/varから離れたいから)
* /proc プロセスをファイルに落とし込んだディレクトリを管理する、プロセスファイルシステムをマウントしたディレクトリ
  * PID=1のプロセスの中身を見たいなら $ ls /proc/1 で表示できる
  * 最近だとカーネルのリアルタイム情報に関する情報も保存されていたりする(数字のディレクトリ以外のファイル)
* /tmp|/var/tmp /tmpはリブートするとファイルが消失し易いが、/var/tmpはファイルが消えない

### ディレクトリを使い分ける基準
* バックアップは必要か
* ユーザ毎に必要か
* パーミッションは分ける必要があるか
* シェルでグロブの対象にすると便利か？グロブ？




##### 蛇足
* mountコマンドを使うと、現在使っているシステムでどのようなファイルシステムが使われているのか調べられる
* ext4はLinuxで現在最も一般的なファイルシステム(`$ mount -t ext4`)
* システムコールの呼び出しはかなり遅い
* アンバッファードモードのstdioストリームは書き込むと一切バッファリングすることなく即座にwrite()される
  * 標準エラー出力に対応するストリームstderrは最初からアンバッファードモードになっている(デバッグやエラーメッセージを即座に書き出したいから
* getsは本質的にバッファーオーバーフローの欠陥があり、これを使ったワームがたくさんある
* libcには沢山の問題をはらんでいる関数が存在するので注意
* scanfもgetsと同様の危険があるため非推奨
* straceコマンドで実際のプログラムがどのようなシステムコールを行っているのかわかる
  * 普通に使うとわかりづらいのでopen,read,write,closeだけに絞ることもできる(strace -e trace=open,read,write,close ./cat data > /dev/null)みたいな感じ
* Books?の正規表現は「Book」と「Books」となる
* iconvは文字コードの相互変換ライブラリで例えばEUC_JPとUTF-8の変換ができる、Linuxだとlibcに入っている
* ネットワークファイルシステム（NFS、SAMBA）P183
* シェルのバッククォートの使われ方
  * cat /var/run/xxx.pid
  -> 76
  * kill -HUP `cat /var/run/xxx.pid`
  -> kill -HUP 76と同義
* devfsとudevの違いはカーネルの一部としてのプログラムか、カーネル外のプログラムかの違い(P186)
